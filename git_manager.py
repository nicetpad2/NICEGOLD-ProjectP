#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üöÄ NICEGOLD Git Repository Manager
‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Git repository ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö NICEGOLD Enterprise
"""

import json
import logging
import os
import subprocess
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class GitManager:
    """‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Git repository ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö NICEGOLD"""
    
    def __init__(self, repo_path: str = None):
        self.repo_path = repo_path or os.getcwd()
        self.setup_logging()
        
    def setup_logging(self):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ logging"""
        log_dir = Path(self.repo_path) / "logs" / "git"
        log_dir.mkdir(parents=True, exist_ok=True)
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_dir / f"git_{datetime.now().strftime('%Y%m%d')}.log"),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def run_git_command(self, command: List[str], capture_output: bool = True) -> Tuple[bool, str]:
        """‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á Git"""
        try:
            full_command = ["git"] + command
            result = subprocess.run(
                full_command,
                cwd=self.repo_path,
                capture_output=capture_output,
                text=True,
                timeout=300  # 5 minutes timeout
            )
            
            if result.returncode == 0:
                self.logger.info(f"‚úÖ Git command succeeded: {' '.join(command)}")
                return True, result.stdout.strip()
            else:
                self.logger.error(f"‚ùå Git command failed: {' '.join(command)}")
                self.logger.error(f"Error: {result.stderr}")
                return False, result.stderr.strip()
                
        except subprocess.TimeoutExpired:
            self.logger.error(f"‚è∞ Git command timed out: {' '.join(command)}")
            return False, "Command timed out"
        except Exception as e:
            self.logger.error(f"üí• Git command error: {e}")
            return False, str(e)

    def check_git_status(self) -> Dict:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Git repository"""
        status = {
            "is_git_repo": False,
            "current_branch": None,
            "remote_url": None,
            "status": None,
            "staged_files": [],
            "modified_files": [],
            "untracked_files": [],
            "ahead_behind": {"ahead": 0, "behind": 0}
        }
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Git repo ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        success, _ = self.run_git_command(["status", "--porcelain"])
        if not success:
            return status
            
        status["is_git_repo"] = True
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö branch ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        success, branch = self.run_git_command(["branch", "--show-current"])
        if success:
            status["current_branch"] = branch
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö remote URL
        success, url = self.run_git_command(["remote", "get-url", "origin"])
        if success:
            status["remote_url"] = url
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏ü‡∏•‡πå
        success, git_status = self.run_git_command(["status", "--porcelain"])
        if success:
            status["status"] = git_status
            self._parse_git_status(git_status, status)
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ahead/behind
        success, ahead_behind = self.run_git_command([
            "rev-list", "--left-right", "--count", "HEAD...@{upstream}"
        ])
        if success and ahead_behind:
            try:
                ahead, behind = ahead_behind.split('\t')
                status["ahead_behind"] = {"ahead": int(ahead), "behind": int(behind)}
            except:
                pass
        
        return status

    def _parse_git_status(self, git_status: str, status: Dict):
        """‡πÅ‡∏õ‡∏•‡∏á‡∏ú‡∏• git status"""
        for line in git_status.split('\n'):
            if not line.strip():
                continue
                
            status_code = line[:2]
            filename = line[3:]
            
            if status_code[0] in ['A', 'M', 'D', 'R', 'C']:
                status["staged_files"].append(filename)
            elif status_code[1] in ['M', 'D']:
                status["modified_files"].append(filename)
            elif status_code == '??':
                status["untracked_files"].append(filename)

    def setup_git_user(self, name: str = None, email: str = None):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ Git"""
        if not name:
            name = "NICEGOLD Administrator"
        if not email:
            email = "admin@nicegold.local"
            
        self.run_git_command(["config", "user.name", name])
        self.run_git_command(["config", "user.email", email])
        
        self.logger.info(f"‚úÖ Git user configured: {name} <{email}>")

    def add_files(self, files: List[str] = None) -> bool:
        """‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏Ç‡πâ‡∏≤ staging area"""
        if files is None:
            # Add all files
            success, _ = self.run_git_command(["add", "."])
        else:
            # Add specific files
            success, _ = self.run_git_command(["add"] + files)
            
        if success:
            self.logger.info(f"‚úÖ Files added to staging: {files or 'all files'}")
        return success

    def commit_changes(self, message: str, description: str = None) -> bool:
        """Commit ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á"""
        full_message = message
        if description:
            full_message = f"{message}\n\n{description}"
            
        success, output = self.run_git_command(["commit", "-m", full_message])
        
        if success:
            self.logger.info(f"‚úÖ Changes committed: {message}")
        return success

    def push_to_remote(self, branch: str = None, force: bool = False) -> bool:
        """Push changes ‡πÑ‡∏õ‡∏¢‡∏±‡∏á remote repository"""
        if not branch:
            branch = "main"
            
        cmd = ["push", "origin", branch]
        if force:
            cmd.insert(1, "--force-with-lease")
            
        success, output = self.run_git_command(cmd)
        
        if success:
            self.logger.info(f"‚úÖ Successfully pushed to {branch}")
        else:
            self.logger.error(f"‚ùå Failed to push to {branch}: {output}")
            
        return success

    def pull_from_remote(self, branch: str = None) -> bool:
        """Pull changes ‡∏à‡∏≤‡∏Å remote repository"""
        if not branch:
            branch = "main"
            
        success, output = self.run_git_command(["pull", "origin", branch])
        
        if success:
            self.logger.info(f"‚úÖ Successfully pulled from {branch}")
        else:
            self.logger.error(f"‚ùå Failed to pull from {branch}: {output}")
            
        return success

    def create_and_push_branch(self, branch_name: str) -> bool:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á branch ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞ push"""
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á branch ‡πÉ‡∏´‡∏°‡πà
        success, _ = self.run_git_command(["checkout", "-b", branch_name])
        if not success:
            return False
            
        # Push branch ‡πÉ‡∏´‡∏°‡πà
        success, _ = self.run_git_command(["push", "-u", "origin", branch_name])
        
        if success:
            self.logger.info(f"‚úÖ Created and pushed new branch: {branch_name}")
        return success

    def sync_with_remote(self) -> bool:
        """‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Å‡∏±‡∏ö remote repository"""
        self.logger.info("üîÑ Syncing with remote repository...")
        
        # Fetch ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        success, _ = self.run_git_command(["fetch", "origin"])
        if not success:
            return False
            
        # Pull ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        success = self.pull_from_remote()
        
        return success

    def smart_commit_and_push(self, 
                             message: str = None, 
                             description: str = None,
                             files: List[str] = None) -> bool:
        """Commit ‡πÅ‡∏•‡∏∞ Push ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞"""
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
        status = self.check_git_status()
        
        if not status["is_git_repo"]:
            self.logger.error("‚ùå Not a git repository")
            return False
            
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ default commit message
        if not message:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            message = f"üöÄ NICEGOLD Update - {timestamp}"
            
        if not description:
            total_files = (len(status["staged_files"]) + 
                          len(status["modified_files"]) + 
                          len(status["untracked_files"]))
            description = f"Updated {total_files} files in NICEGOLD Enterprise system"
        
        try:
            # 1. Add files
            if not self.add_files(files):
                return False
                
            # 2. Commit changes
            if not self.commit_changes(message, description):
                return False
                
            # 3. Sync with remote (pull latest changes)
            if not self.sync_with_remote():
                self.logger.warning("‚ö†Ô∏è Failed to sync with remote, continuing with push...")
                
            # 4. Push to remote
            if not self.push_to_remote():
                return False
                
            self.logger.info("üéâ Successfully committed and pushed changes!")
            return True
            
        except Exception as e:
            self.logger.error(f"üí• Error during commit and push: {e}")
            return False

    def generate_status_report(self) -> Dict:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Git"""
        status = self.check_git_status()
        
        report = {
            "timestamp": datetime.now().isoformat(),
            "repository_status": status,
            "summary": {
                "total_staged": len(status.get("staged_files", [])),
                "total_modified": len(status.get("modified_files", [])),
                "total_untracked": len(status.get("untracked_files", [])),
                "needs_push": status.get("ahead_behind", {}).get("ahead", 0) > 0,
                "needs_pull": status.get("ahead_behind", {}).get("behind", 0) > 0
            }
        }
        
        return report

    def save_status_report(self, filename: str = None):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"git_status_report_{timestamp}.json"
            
        report = self.generate_status_report()
        
        reports_dir = Path(self.repo_path) / "reports" / "git"
        reports_dir.mkdir(parents=True, exist_ok=True)
        
        report_path = reports_dir / filename
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
        self.logger.info(f"üìä Status report saved: {report_path}")
        return report_path


def main():
    """‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö CLI"""
    import argparse
    
    parser = argparse.ArgumentParser(description="NICEGOLD Git Manager")
    parser.add_argument("--action", 
                       choices=["status", "commit", "push", "sync", "smart-push"], 
                       default="status",
                       help="Action to perform")
    parser.add_argument("--message", "-m", help="Commit message")
    parser.add_argument("--description", "-d", help="Commit description")
    parser.add_argument("--files", nargs="*", help="Specific files to add")
    parser.add_argument("--force", action="store_true", help="Force push")
    parser.add_argument("--report", action="store_true", help="Generate status report")
    
    args = parser.parse_args()
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á GitManager instance
    git_manager = GitManager()
    
    if args.action == "status":
        status = git_manager.check_git_status()
        print("\nüîç Git Repository Status:")
        print(f"‚îú‚îÄ‚îÄ Repository: {'‚úÖ' if status['is_git_repo'] else '‚ùå'}")
        print(f"‚îú‚îÄ‚îÄ Branch: {status.get('current_branch', 'Unknown')}")
        print(f"‚îú‚îÄ‚îÄ Remote: {status.get('remote_url', 'Not configured')}")
        print(f"‚îú‚îÄ‚îÄ Staged files: {len(status.get('staged_files', []))}")
        print(f"‚îú‚îÄ‚îÄ Modified files: {len(status.get('modified_files', []))}")
        print(f"‚îú‚îÄ‚îÄ Untracked files: {len(status.get('untracked_files', []))}")
        print(f"‚îî‚îÄ‚îÄ Ahead/Behind: +{status.get('ahead_behind', {}).get('ahead', 0)}/-{status.get('ahead_behind', {}).get('behind', 0)}")
        
    elif args.action == "commit":
        if not args.message:
            print("‚ùå Commit message required for commit action")
            return
        git_manager.add_files(args.files)
        git_manager.commit_changes(args.message, args.description)
        
    elif args.action == "push":
        git_manager.push_to_remote(force=args.force)
        
    elif args.action == "sync":
        git_manager.sync_with_remote()
        
    elif args.action == "smart-push":
        git_manager.smart_commit_and_push(
            message=args.message,
            description=args.description,
            files=args.files
        )
    
    if args.report:
        git_manager.save_status_report()


if __name__ == "__main__":
    main()
